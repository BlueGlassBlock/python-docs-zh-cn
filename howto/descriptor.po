# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2020, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Shengjing Zhu <zsj950618@gmail.com>, 2018
# Yinuo Huang <yinuo.huang15@imperial.ac.uk>, 2018
# Fei Yin <icebirds@163.com>, 2018
# Junkai Shao <skaifun.dev@gmail.com>, 2018
# banxi <banxi1988@gmail.com>, 2019
# Siyuan Xu <mf20070535@126.com>, 2019
# ppcfish <ppcfish@gmail.com>, 2019
# Freesand Leo <yuqinju@163.com>, 2020
# WH-2099 <wh2099@outlook.com>, 2020
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.9\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-11-02 04:31+0000\n"
"PO-Revision-Date: 2017-02-16 17:44+0000\n"
"Last-Translator: WH-2099 <wh2099@outlook.com>, 2020\n"
"Language-Team: Chinese (China) (https://www.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../howto/descriptor.rst:5
msgid "Descriptor HowTo Guide"
msgstr "描述器使用指南"

#: ../../howto/descriptor.rst:0
msgid "Author"
msgstr "作者"

#: ../../howto/descriptor.rst:7
msgid "Raymond Hettinger"
msgstr "Raymond Hettinger"

#: ../../howto/descriptor.rst:0
msgid "Contact"
msgstr "联系方式"

#: ../../howto/descriptor.rst:8
msgid "<python at rcn dot com>"
msgstr "<python at rcn dot com>"

#: ../../howto/descriptor.rst:11
msgid "Contents"
msgstr "内容"

#: ../../howto/descriptor.rst:13
msgid ""
":term:`Descriptors <descriptor>` let objects customize attribute lookup, "
"storage, and deletion."
msgstr ":term:`描述器 <descriptor>` 让对象能够自定义属性查找、存储和删除的操作。"

#: ../../howto/descriptor.rst:16
msgid "This guide has four major sections:"
msgstr "本指南主要分为四个部分："

#: ../../howto/descriptor.rst:18
msgid ""
"The \"primer\" gives a basic overview, moving gently from simple examples, "
"adding one feature at a time.  It is a great place to start."
msgstr "“入门” 部分从简单的示例着手，逐步添加特性，从而给出基本的概述。这是一个很好的起点。"

#: ../../howto/descriptor.rst:21
msgid ""
"The second section shows a complete, practical descriptor example.  If you "
"already know the basics, start there."
msgstr "第二部分展示了完整的、实用的描述器示例。如果您已经掌握了基础知识，请从此处开始。"

#: ../../howto/descriptor.rst:24
msgid ""
"The third section provides a more technical tutorial that goes into the "
"detailed mechanics of how descriptors work.  Most people don't need this "
"level of detail."
msgstr "第三部分提供了更多技术教程，详细介绍了描述符如何工作。大多数人并不需要深入到这种程度。"

#: ../../howto/descriptor.rst:28
msgid ""
"The last section has pure Python equivalents for built-in descriptors that "
"are written in C.  Read this if you're curious about how functions turn into"
" bound methods or about how to implement common tools like "
":func:`classmethod`, :func:`staticmethod`, and :func:`property`."
msgstr ""
"最后一部分有对内置描述器（用 C 编写）的纯 Python 等价实现。如果您对函数如何变成绑定方法或如何实现类似 "
":func:`classmethod`， :func:`staticmethod` 和 :func:`property` "
"这样的常见工具感兴趣，请阅读此部分。"

#: ../../howto/descriptor.rst:35
msgid "Primer"
msgstr "入门"

#: ../../howto/descriptor.rst:37
msgid ""
"In this primer, we start with the most basic possible example and then we'll"
" add new capabilities one by one."
msgstr "现在，让我们从最基本的示例开始，然后逐步添加新功能。"

#: ../../howto/descriptor.rst:42
msgid "Simple example: A descriptor that returns a constant"
msgstr "简单示例：返回常量的描述器"

#: ../../howto/descriptor.rst:44
msgid ""
"The :class:`Ten` class is a descriptor that always returns the constant "
"``10``::"
msgstr "类 :class:`Ten` 是一个总是返回常量 ``10`` 的描述器::"

#: ../../howto/descriptor.rst:51
msgid ""
"To use the descriptor, it must be stored as a class variable in another "
"class::"
msgstr "要使用描述器，它必须作为一个类变量存储在另一个类中::"

#: ../../howto/descriptor.rst:57
msgid ""
"An interactive session shows the difference between normal attribute lookup "
"and descriptor lookup::"
msgstr "用交互式会话查看普通属性查找和描述器查找之间的区别::"

#: ../../howto/descriptor.rst:66
msgid ""
"In the ``a.x`` attribute lookup, the dot operator finds the value ``5`` "
"stored in the class dictionary.  In the ``a.y`` descriptor lookup, the dot "
"operator calls the descriptor's :meth:`__get__()` method.  That method "
"returns ``10``. Note that the value ``10`` is not stored in either the class"
" dictionary or the instance dictionary.  Instead, the value ``10`` is "
"computed on demand."
msgstr ""
"在 ``a.x`` 属性查找中，点运算符会找到存储在类字典中的值 ``5``。在 ``a.y`` 描述器查找中，点运算符调用描述器的 "
":meth:`__get__()` 方法。这个方法返回了 ``10``。请注意，值 ``10`` 既不存储在类字典中也不存储在实例字典中。相反，值 "
"``10`` 是在调用时才取到的。"

#: ../../howto/descriptor.rst:72
msgid ""
"This example shows how a simple descriptor works, but it isn't very useful. "
"For retrieving constants, normal attribute lookup would be better."
msgstr "这个简单的例子展示了一个描述器是如何工作的，但它不是很有用。在查找常量时，用常规属性查找会更好。"

#: ../../howto/descriptor.rst:75
msgid ""
"In the next section, we'll create something more useful, a dynamic lookup."
msgstr "在下一节中，我们将创建更有用的东西，即动态查找。"

#: ../../howto/descriptor.rst:79
msgid "Dynamic lookups"
msgstr "动态查找"

#: ../../howto/descriptor.rst:81
msgid ""
"Interesting descriptors typically run computations instead of doing "
"lookups::"
msgstr "有趣的描述器通常运行计算而不是查找::"

#: ../../howto/descriptor.rst:97
msgid ""
"An interactive session shows that the lookup is dynamic — it computes "
"different, updated answers each time::"
msgstr "交互式会话显示查找是动态的，每次都会计算不同的，经过更新的返回值::"

#: ../../howto/descriptor.rst:111
msgid ""
"Besides showing how descriptors can run computations, this example also "
"reveals the purpose of the parameters to :meth:`__get__`.  The *self* "
"parameter is *size*, an instance of *DirectorySize*.  The *obj* parameter is"
" either *g* or *s*, an instance of *Directory*.  It is *obj* parameter that "
"lets the :meth:`__get__` method learn the target directory.  The *objtype* "
"parameter is the class *Directory*."
msgstr ""
"除了说明描述器如何运行计算，这个例子也揭示了 :meth:`__get__` 参数的目的。形参 *self* 接收的实参是 *size*，即 "
"*DirectorySize* 的一个实例。形参 *obj* 接收的实参是 *g* 或 *s*，即 *Directory* 的一个实例。而正是 "
"*obj* 让 :meth:`__get__` 方法获得了作为目标的目录。形参 *objtype* 接收的实参是 *Directory* 类。"

#: ../../howto/descriptor.rst:120
msgid "Managed attributes"
msgstr "托管属性"

#: ../../howto/descriptor.rst:122
msgid ""
"A popular use for descriptors is managing access to instance data.  The "
"descriptor is assigned to a public attribute in the class dictionary while "
"the actual data is stored as a private attribute in the instance dictionary."
"  The descriptor's :meth:`__get__` and :meth:`__set__` methods are triggered"
" when the public attribute is accessed."
msgstr ""
"描述器的一种流行用法是托管对实例数据的访问。描述器被分配给类字典中的公开属性，而实际数据作为私有属性存储在实例字典中。当访问公开属性时，会触发描述器的"
"  :meth:`__get__` 和 :meth:`__set__` 方法。"

#: ../../howto/descriptor.rst:128
msgid ""
"In the following example, *age* is the public attribute and *_age* is the "
"private attribute.  When the public attribute is accessed, the descriptor "
"logs the lookup or update::"
msgstr "在下面的例子中，*age* 是公开属性，*_age* 是私有属性。当访问公开属性时，描述器会记录下查找或更新的日志::"

#: ../../howto/descriptor.rst:159
msgid ""
"An interactive session shows that all access to the managed attribute *age* "
"is logged, but that the regular attribute *name* is not logged::"
msgstr "交互式会话展示中，对托管属性 *age* 的所有访问都被记录了下来，但常规属性 *name* 则未被记录::"

#: ../../howto/descriptor.rst:185
msgid ""
"One major issue with this example is the private name *_age* is hardwired in"
" the *LoggedAgeAccess* class.  That means that each instance can only have "
"one logged attribute and that its name is unchangeable.  In the next "
"example, we'll fix that problem."
msgstr ""
"此示例的一个主要问题是私有名称 *_age* 在类 *LoggedAgeAccess* "
"中是硬耦合的。这意味着每个实例只能有一个用于记录的属性，并且其名称不可更改。"

#: ../../howto/descriptor.rst:192
msgid "Customized Names"
msgstr "自定义名称"

#: ../../howto/descriptor.rst:194
msgid ""
"When a class uses descriptors, it can inform each descriptor about what "
"variable name was used."
msgstr "当一个类使用描述器时，它可以告知每个描述器使用了什么变量名。"

#: ../../howto/descriptor.rst:197
msgid ""
"In this example, the :class:`Person` class has two descriptor instances, "
"*name* and *age*.  When the :class:`Person` class is defined, it makes a "
"callback to :meth:`__set_name__` in *LoggedAccess* so that the field names "
"can be recorded, giving each descriptor its own *public_name* and "
"*private_name*::"
msgstr ""
"在此示例中， :class:`Person`  类具有两个描述器实例 *name* 和 *age*。当类  :class:`Person` "
"被定义的时候，他回调了 *LoggedAccess* 中的 :meth:`__set_name__` 来记录字段名称，让每个描述器拥有自己的 "
"*public_name* 和 *private_name*::"

#: ../../howto/descriptor.rst:233
msgid ""
"An interactive session shows that the :class:`Person` class has called "
":meth:`__set_name__` so that the field names would be recorded.  Here we "
"call :func:`vars` to lookup the descriptor without triggering it::"
msgstr ""
"交互交互式会话显示类 :class:`Person` 调用了 :meth:`__set_name__` 方法来记录字段的名称。在这里，我们调用 "
":func:`vars` 来查找描述器而不触发它::"

#: ../../howto/descriptor.rst:242
msgid "The new class now logs access to both *name* and *age*::"
msgstr "现在，新类会记录对 *name* 和 *age* 二者的访问::"

#: ../../howto/descriptor.rst:251
msgid "The two *Person* instances contain only the private names::"
msgstr "这两个 *Person* 实例仅包含私有名称::"

#: ../../howto/descriptor.rst:260
msgid "Closing thoughts"
msgstr "总结思想"

#: ../../howto/descriptor.rst:262
msgid ""
"A :term:`descriptor` is what we call any object that defines "
":meth:`__get__`, :meth:`__set__`, or :meth:`__delete__`."
msgstr ""
" :term:`descriptor` 就是任何一个定义了 :meth:`__get__`，:meth:`__set__` 或 "
":meth:`__delete__` 的对象。"

#: ../../howto/descriptor.rst:265
msgid ""
"Optionally, descriptors can have a :meth:`__set_name__` method.  This is "
"only used in cases where a descriptor needs to know either the class where "
"it was created or the name of class variable it was assigned to."
msgstr ""

#: ../../howto/descriptor.rst:269
msgid ""
"Descriptors get invoked by the dot operator during attribute lookup.  If a "
"descriptor is accessed indirectly with "
"``vars(some_class)[descriptor_name]``, the descriptor instance is returned "
"without invoking it."
msgstr ""

#: ../../howto/descriptor.rst:273
msgid ""
"Descriptors only work when used as class variables.  When put in instances, "
"they have no effect."
msgstr ""

#: ../../howto/descriptor.rst:276
msgid ""
"The main motivation for descriptors is to provide a hook allowing objects "
"stored in class variables to control what happens during dotted lookup."
msgstr ""

#: ../../howto/descriptor.rst:279
msgid ""
"Traditionally, the calling class controls what happens during lookup. "
"Descriptors invert that relationship and allow the data being looked-up to "
"have a say in the matter."
msgstr ""

#: ../../howto/descriptor.rst:283
msgid ""
"Descriptors are used throughout the language.  It is how functions turn into"
" bound methods.  Common tools like :func:`classmethod`, "
":func:`staticmethod`, :func:`property`, and "
":func:`functools.cached_property` are all implemented as descriptors."
msgstr ""

#: ../../howto/descriptor.rst:290
msgid "Complete Practical Example"
msgstr "完整的实际例子"

#: ../../howto/descriptor.rst:292
msgid ""
"In this example, we create a practical and powerful tool for locating "
"notoriously hard to find data corruption bugs."
msgstr "在此示例中，我们创建了一个实用而强大的工具来查找难以发现的数据损坏错误。"

#: ../../howto/descriptor.rst:297
msgid "Validator class"
msgstr "验证器类"

#: ../../howto/descriptor.rst:299
msgid ""
"A validator is a descriptor for managed attribute access.  Prior to storing "
"any data, it verifies that the new value meets various type and range "
"restrictions.  If those restrictions aren't met, it raises an exception to "
"prevent data corruption at its source."
msgstr ""

#: ../../howto/descriptor.rst:304
msgid ""
"This :class:`Validator` class is both an :term:`abstract base class` and a "
"managed attribute descriptor::"
msgstr ""

#: ../../howto/descriptor.rst:325
msgid ""
"Custom validators need to inherit from :class:`Validator` and must supply a "
":meth:`validate` method to test various restrictions as needed."
msgstr ""

#: ../../howto/descriptor.rst:330
msgid "Custom validators"
msgstr "自定义验证器"

#: ../../howto/descriptor.rst:332
msgid "Here are three practical data validation utilities:"
msgstr ""

#: ../../howto/descriptor.rst:334
msgid ""
":class:`OneOf` verifies that a value is one of a restricted set of options."
msgstr ""

#: ../../howto/descriptor.rst:336
msgid ""
":class:`Number` verifies that a value is either an :class:`int` or "
":class:`float`.  Optionally, it verifies that a value is between a given "
"minimum or maximum."
msgstr ""

#: ../../howto/descriptor.rst:340
msgid ""
":class:`String` verifies that a value is a :class:`str`.  Optionally, it "
"validates a given minimum or maximum length.  It can validate a user-defined"
" `predicate <https://en.wikipedia.org/wiki/Predicate_(mathematical_logic)>`_"
" as well."
msgstr ""

#: ../../howto/descriptor.rst:399
msgid "Practical use"
msgstr "实际使用"

#: ../../howto/descriptor.rst:401
msgid "Here's how the data validators can be used in a real class::"
msgstr "这是在真实类中使用数据验证器的方法::"

#: ../../howto/descriptor.rst:414
msgid "The descriptors prevent invalid instances from being created::"
msgstr "描述器阻止无效实例的创建::"

#: ../../howto/descriptor.rst:424
msgid "Technical Tutorial"
msgstr "技术教程"

#: ../../howto/descriptor.rst:426
msgid ""
"What follows is a more technical tutorial for the mechanics and details of "
"how descriptors work."
msgstr "接下来是专业性更强的技术教程，以及描述器工作原理的详细信息。"

#: ../../howto/descriptor.rst:431
msgid "Abstract"
msgstr "摘要"

#: ../../howto/descriptor.rst:433
msgid ""
"Defines descriptors, summarizes the protocol, and shows how descriptors are "
"called.  Provides an example showing how object relational mappings work."
msgstr "定义描述符，总结协议，并说明如何调用描述符。提供一个展示对象关系映射如何工作的示例。"

#: ../../howto/descriptor.rst:436
msgid ""
"Learning about descriptors not only provides access to a larger toolset, it "
"creates a deeper understanding of how Python works and an appreciation for "
"the elegance of its design."
msgstr "学习描述器不仅能提供接触到更多工具集的方法，还能更深地理解 Python 工作的原理并更加体会到其设计的优雅性。"

#: ../../howto/descriptor.rst:442
msgid "Definition and Introduction"
msgstr "定义和简介"

#: ../../howto/descriptor.rst:444
msgid ""
"In general, a descriptor is an object attribute with \"binding behavior\", "
"one whose attribute access has been overridden by methods in the descriptor "
"protocol.  Those methods are :meth:`__get__`, :meth:`__set__`, and "
":meth:`__delete__`.  If any of those methods are defined for an object, it "
"is said to be a :term:`descriptor`."
msgstr ""
"一般地，一个描述器是一个包含 “绑定行为” 的对象，对其属性的访问被描述器协议中定义的方法覆盖。这些方法是 "
":meth:`__get__`，:meth:`__set__` 和 "
":meth:`__delete__`。如果在某个对象中定义了这些方法中的任意一个，那么就可以说这个对象是一个 :term:`descriptor`。"

#: ../../howto/descriptor.rst:450
msgid ""
"The default behavior for attribute access is to get, set, or delete the "
"attribute from an object's dictionary.  For instance, ``a.x`` has a lookup "
"chain starting with ``a.__dict__['x']``, then ``type(a).__dict__['x']``, and"
" continuing through the base classes of ``type(a)``. If the looked-up value "
"is an object defining one of the descriptor methods, then Python may "
"override the default behavior and invoke the descriptor method instead. "
"Where this occurs in the precedence chain depends on which descriptor "
"methods were defined."
msgstr ""
"属性访问的默认行为是从一个对象的字典中获取、设置或删除属性。对于实例来说，``a.x`` 的查找顺序会从 ``a.__dict__['x']`` "
"开始，然后是 ``type(a).__dict__['x']``，接下来依次查找 ``type(a)`` 的基类。 "
"如果找到的值是定义了某个描述器方法的对象，则 Python "
"可能会重写默认行为并转而发起调用描述器方法。这具体发生在优先级链的哪个环节则要根据所定义的描述器方法及其被调用的方式来决定。"

#: ../../howto/descriptor.rst:459
msgid ""
"Descriptors are a powerful, general purpose protocol.  They are the "
"mechanism behind properties, methods, static methods, class methods, and "
":func:`super()`.  They are used throughout Python itself.  Descriptors "
"simplify the underlying C code and offer a flexible set of new tools for "
"everyday Python programs."
msgstr ""
"描述器是一个强大而通用的协议。 它们是属性、方法、静态方法、类方法和 :func:`super()` 背后的实现机制。 它们在 Python "
"内部被广泛使用。 描述器简化了底层的 C 代码并为 Python 的日常程序提供了一组灵活的新工具。"

#: ../../howto/descriptor.rst:467
msgid "Descriptor Protocol"
msgstr "描述器协议"

#: ../../howto/descriptor.rst:469
msgid "``descr.__get__(self, obj, type=None) -> value``"
msgstr "``descr.__get__(self, obj, type=None) -> value``"

#: ../../howto/descriptor.rst:471
msgid "``descr.__set__(self, obj, value) -> None``"
msgstr "``descr.__set__(self, obj, value) -> None``"

#: ../../howto/descriptor.rst:473
msgid "``descr.__delete__(self, obj) -> None``"
msgstr "``descr.__delete__(self, obj) -> None``"

#: ../../howto/descriptor.rst:475
msgid ""
"That is all there is to it.  Define any of these methods and an object is "
"considered a descriptor and can override default behavior upon being looked "
"up as an attribute."
msgstr "描述器的方法就这些。一个对象只要定义了以上方法中的任何一个，就被视为描述器，并在被作为属性时覆盖其默认行为。"

#: ../../howto/descriptor.rst:479
msgid ""
"If an object defines :meth:`__set__` or :meth:`__delete__`, it is considered"
" a data descriptor.  Descriptors that only define :meth:`__get__` are called"
" non-data descriptors (they are typically used for methods but other uses "
"are possible)."
msgstr ""
"如果一个对象定义了 :meth:`__set__` 或 :meth:`__delete__`，则它会被视为数据描述器。 仅定义了 "
":meth:`__get__` 的描述器称为非数据描述器（它们通常被用于方法，但也可以有其他用途）。"

#: ../../howto/descriptor.rst:484
msgid ""
"Data and non-data descriptors differ in how overrides are calculated with "
"respect to entries in an instance's dictionary.  If an instance's dictionary"
" has an entry with the same name as a data descriptor, the data descriptor "
"takes precedence.  If an instance's dictionary has an entry with the same "
"name as a non-data descriptor, the dictionary entry takes precedence."
msgstr ""
"数据和非数据描述器的不同之处在于，如何计算实例字典中条目的替代值。如果实例的字典具有与数据描述器同名的条目，则数据描述器优先。如果实例的字典具有与非数据描述器同名的条目，则该字典条目优先。"

#: ../../howto/descriptor.rst:490
msgid ""
"To make a read-only data descriptor, define both :meth:`__get__` and "
":meth:`__set__` with the :meth:`__set__` raising an :exc:`AttributeError` "
"when called.  Defining the :meth:`__set__` method with an exception raising "
"placeholder is enough to make it a data descriptor."
msgstr ""
"为了使数据描述器成为只读的，应该同时定义 :meth:`__get__` 和 :meth:`__set__` ，并在 :meth:`__set__` "
"中引发 :exc:`AttributeError` 。用引发异常的占位符定义 :meth:`__set__`  方法使其成为数据描述器。"

#: ../../howto/descriptor.rst:497
msgid "Overview of Descriptor Invocation"
msgstr "描述器调用概述"

#: ../../howto/descriptor.rst:499
msgid ""
"A descriptor can be called directly with ``desc.__get__(obj)`` or "
"``desc.__get__(None, cls)``."
msgstr ""

#: ../../howto/descriptor.rst:502
msgid ""
"But it is more common for a descriptor to be invoked automatically from "
"attribute access."
msgstr ""

#: ../../howto/descriptor.rst:505
msgid ""
"The expression ``obj.x`` looks up the attribute ``x`` in the chain of "
"namespaces for ``obj``.  If the search finds a descriptor, its "
":meth:`__get__` method is invoked according to the precedence rules listed "
"below."
msgstr ""

#: ../../howto/descriptor.rst:509
msgid ""
"The details of invocation depend on whether ``obj`` is an object, class, or "
"instance of super."
msgstr ""

#: ../../howto/descriptor.rst:514
msgid "Invocation from an Instance"
msgstr "通过示例调用"

#: ../../howto/descriptor.rst:516
msgid ""
"Instance lookup scans through a chain of namespaces giving data descriptors "
"the highest priority, followed by instance variables, then non-data "
"descriptors, then class variables, and lastly :meth:`__getattr__` if it is "
"provided."
msgstr ""

#: ../../howto/descriptor.rst:521
msgid ""
"If a descriptor is found for ``a.x``, then it is invoked with: "
"``desc.__get__(a, type(a))``."
msgstr ""

#: ../../howto/descriptor.rst:524
msgid ""
"The logic for a dotted lookup is in :meth:`object.__getattribute__`.  Here "
"is a pure Python equivalent::"
msgstr ""

#: ../../howto/descriptor.rst:548
msgid ""
"The :exc:`TypeError` exception handler is needed because the instance "
"dictionary doesn't exist when its class defines :term:`__slots__`."
msgstr ""

#: ../../howto/descriptor.rst:553
msgid "Invocation from a Class"
msgstr "通过类调用"

#: ../../howto/descriptor.rst:555
msgid ""
"The logic for a dotted lookup such as ``A.x`` is in "
":meth:`type.__getattribute__`.  The steps are similar to those for "
":meth:`object.__getattribute__` but the instance dictionary lookup is "
"replaced by a search through the class's :term:`method resolution order`."
msgstr ""

#: ../../howto/descriptor.rst:560
msgid ""
"If a descriptor is found, it is invoked with ``desc.__get__(None, A)``."
msgstr ""

#: ../../howto/descriptor.rst:562
msgid ""
"The full C implementation can be found in :c:func:`type_getattro()` and "
":c:func:`_PyType_Lookup()` in :source:`Objects/typeobject.c`."
msgstr ""

#: ../../howto/descriptor.rst:567
msgid "Invocation from Super"
msgstr "通过 super 调用"

#: ../../howto/descriptor.rst:569
msgid ""
"The logic for super's dotted lookup is in the :meth:`__getattribute__` "
"method for object returned by :class:`super()`."
msgstr ""

#: ../../howto/descriptor.rst:572
msgid ""
"A dotted lookup such as ``super(A, obj).m`` searches "
"``obj.__class__.__mro__`` for the base class ``B`` immediately following "
"``A`` and then returns ``B.__dict__['m'].__get__(obj, A)``.  If not a "
"descriptor, ``m`` is returned unchanged."
msgstr ""

#: ../../howto/descriptor.rst:577
msgid ""
"The full C implementation can be found in :c:func:`super_getattro()` in "
":source:`Objects/typeobject.c`.  A pure Python equivalent can be found in "
"`Guido's Tutorial "
"<https://www.python.org/download/releases/2.2.3/descrintro/#cooperation>`_."
msgstr ""

#: ../../howto/descriptor.rst:584
msgid "Summary of Invocation Logic"
msgstr "调用逻辑总结"

#: ../../howto/descriptor.rst:586
msgid ""
"The mechanism for descriptors is embedded in the :meth:`__getattribute__()` "
"methods for :class:`object`, :class:`type`, and :func:`super`."
msgstr ""
"描述器的机制嵌入在 :class:`object`，:class:`type` 和 :func:`super` 的 "
":meth:`__getattribute__()` 方法中。"

#: ../../howto/descriptor.rst:589
msgid "The important points to remember are:"
msgstr "要记住的重要点是："

#: ../../howto/descriptor.rst:591
msgid "Descriptors are invoked by the :meth:`__getattribute__` method."
msgstr "描述器由 :meth:`__getattribute__` 方法调用。"

#: ../../howto/descriptor.rst:593
msgid ""
"Classes inherit this machinery from :class:`object`, :class:`type`, or "
":func:`super`."
msgstr "类从 :class:`object`，:class:`type` 或 :func:`super` 继承此机制。"

#: ../../howto/descriptor.rst:596
msgid ""
"Overriding :meth:`__getattribute__` prevents automatic descriptor calls "
"because all the descriptor logic is in that method."
msgstr "由于描述器的逻辑在 :meth:`__getattribute__` 中，因而重写该方法会阻止描述器的自动调用。"

#: ../../howto/descriptor.rst:599
msgid ""
":meth:`object.__getattribute__` and :meth:`type.__getattribute__` make "
"different calls to :meth:`__get__`.  The first includes the instance and may"
" include the class.  The second puts in ``None`` for the instance and always"
" includes the class."
msgstr ""
":meth:`object.__getattribute__` 和 :meth:`type.__getattribute__` 会用不同的方式调用 "
":meth:`__get__`。前一个会传入实例，也可以包括类。后一个传入的实例为 ``None`` ，并且总是包含类。"

#: ../../howto/descriptor.rst:604
msgid "Data descriptors always override instance dictionaries."
msgstr "数据描述器始终会覆盖实例字典。"

#: ../../howto/descriptor.rst:606
msgid "Non-data descriptors may be overridden by instance dictionaries."
msgstr "非数据描述器会被实例字典覆盖。"

#: ../../howto/descriptor.rst:610
msgid "Automatic Name Notification"
msgstr "自动名称通知"

#: ../../howto/descriptor.rst:612
msgid ""
"Sometimes it is desirable for a descriptor to know what class variable name "
"it was assigned to.  When a new class is created, the :class:`type` "
"metaclass scans the dictionary of the new class.  If any of the entries are "
"descriptors and if they define :meth:`__set_name__`, that method is called "
"with two arguments.  The *owner* is the class where the descriptor is used, "
"the *name* is class variable the descriptor was assigned to."
msgstr ""

#: ../../howto/descriptor.rst:619
msgid ""
"The implementation details are in :c:func:`type_new()` and "
":c:func:`set_names()` in :source:`Objects/typeobject.c`."
msgstr ""

#: ../../howto/descriptor.rst:622
msgid ""
"Since the update logic is in :meth:`type.__new__`, notifications only take "
"place at the time of class creation.  If descriptors are added to the class "
"afterwards, :meth:`__set_name__` will need to be called manually."
msgstr ""

#: ../../howto/descriptor.rst:628
msgid "ORM Example"
msgstr "ORM （对象关系映射）示例"

#: ../../howto/descriptor.rst:630
msgid ""
"The following code is simplified skeleton showing how data descriptors could"
" be used to implement an `object relational mapping "
"<https://en.wikipedia.org/wiki/Object%E2%80%93relational_mapping>`_."
msgstr ""

#: ../../howto/descriptor.rst:634
msgid ""
"The essential idea is that the data is stored in an external database.  The "
"Python instances only hold keys to the database's tables.  Descriptors take "
"care of lookups or updates::"
msgstr ""

#: ../../howto/descriptor.rst:651
msgid ""
"We can use the :class:`Field` class to define \"models\" that describe the "
"schema for each table in a database::"
msgstr ""

#: ../../howto/descriptor.rst:673
msgid ""
"An interactive session shows how data is retrieved from the database and how"
" it can be updated::"
msgstr ""

#: ../../howto/descriptor.rst:693
msgid "Pure Python Equivalents"
msgstr "纯 Python 等价实现"

#: ../../howto/descriptor.rst:695
msgid ""
"The descriptor protocol is simple and offers exciting possibilities.  "
"Several use cases are so common that they have been prepackaged into built-"
"in tools. Properties, bound methods, static methods, and class methods are "
"all based on the descriptor protocol."
msgstr ""
"描述器协议很简单，但它提供了令人兴奋的可能性。有几个用例非常通用，以至于它们已预先打包到内置工具中。属性、绑定方法、静态方法和类方法均基于描述器协议。"

#: ../../howto/descriptor.rst:702
msgid "Properties"
msgstr "属性"

#: ../../howto/descriptor.rst:704
msgid ""
"Calling :func:`property` is a succinct way of building a data descriptor "
"that triggers function calls upon access to an attribute.  Its signature "
"is::"
msgstr "调用 :func:`property` 是构建数据描述器的简洁方式，该数据描述器在访问属性时触发函数调用。它的签名是::"

#: ../../howto/descriptor.rst:709
msgid ""
"The documentation shows a typical use to define a managed attribute ``x``::"
msgstr "该文档显示了定义托管属性 ``x`` 的典型用法::"

#: ../../howto/descriptor.rst:717
msgid ""
"To see how :func:`property` is implemented in terms of the descriptor "
"protocol, here is a pure Python equivalent::"
msgstr "要了解 :func:`property` 如何根据描述器协议实现，这里是一个纯 Python 的等价实现如下::"

#: ../../howto/descriptor.rst:757
msgid ""
"The :func:`property` builtin helps whenever a user interface has granted "
"attribute access and then subsequent changes require the intervention of a "
"method."
msgstr "这个内置的 :func:`property` 每当用户访问属性时生效，随后的变化需要一个方法的参与。"

#: ../../howto/descriptor.rst:761
msgid ""
"For instance, a spreadsheet class may grant access to a cell value through "
"``Cell('b10').value``. Subsequent improvements to the program require the "
"cell to be recalculated on every access; however, the programmer does not "
"want to affect existing client code accessing the attribute directly.  The "
"solution is to wrap access to the value attribute in a property data "
"descriptor::"
msgstr ""
"例如，一个电子表格类可以通过 ``Cell('b10').value`` "
"授予对单元格值的访问权限。对程序的后续改进要求每次访问都要重新计算单元格；但是，程序员不希望影响直接访问该属性的现有客户端代码。解决方案是将对 "
"value 属性的访问包装在属性数据描述器中::"

#: ../../howto/descriptor.rst:778
msgid "Functions and Methods"
msgstr "函数和方法"

#: ../../howto/descriptor.rst:780
msgid ""
"Python's object oriented features are built upon a function based "
"environment. Using non-data descriptors, the two are merged seamlessly."
msgstr "Python 的面向对象功能是在基于函数的环境构建的。通过使用非数据描述器，这两方面完成了无缝融合。"

#: ../../howto/descriptor.rst:783
msgid ""
"Functions stored in class dictionaries get turned into methods when invoked."
" Methods only differ from regular functions in that the object instance is "
"prepended to the other arguments.  By convention, the instance is called "
"*self* but could be called *this* or any other variable name."
msgstr ""
"在调用时，存储在类词典中的函数将被转换为方法。方法与常规函数的不同之处仅在于对象实例被置于其他参数之前。方法与常规函数的不同之处仅在于第一个参数是为对象实例保留的。按照惯例，实例引用称为"
" *self* ，但也可以称为 *this* 或任何其他变量名称。"

#: ../../howto/descriptor.rst:788
msgid ""
"Methods can be created manually with :class:`types.MethodType` which is "
"roughly equivalent to::"
msgstr ""

#: ../../howto/descriptor.rst:803
msgid ""
"To support automatic creation of methods, functions include the "
":meth:`__get__` method for binding methods during attribute access.  This "
"means that functions are non-data descriptors which return bound methods "
"during dotted lookup from an instance.  Here's how it works::"
msgstr ""

#: ../../howto/descriptor.rst:817
msgid ""
"Running the following class in the interpreter shows how the function "
"descriptor works in practice::"
msgstr "在解释器中运行以下类，这显示了函数描述器的实际工作方式::"

#: ../../howto/descriptor.rst:824
msgid ""
"The function has a :term:`qualified name` attribute to support "
"introspection::"
msgstr ""

#: ../../howto/descriptor.rst:829
msgid ""
"Accessing the function through the class dictionary does not invoke "
":meth:`__get__`.  Instead, it just returns the underlying function object::"
msgstr ""

#: ../../howto/descriptor.rst:835
msgid ""
"Dotted access from a class calls :meth:`__get__` which just returns the "
"underlying function unchanged::"
msgstr ""

#: ../../howto/descriptor.rst:841
msgid ""
"The interesting behavior occurs during dotted access from an instance.  The "
"dotted lookup calls :meth:`__get__` which returns a bound method object::"
msgstr ""

#: ../../howto/descriptor.rst:848
msgid ""
"Internally, the bound method stores the underlying function and the bound "
"instance::"
msgstr ""

#: ../../howto/descriptor.rst:857
msgid ""
"If you have ever wondered where *self* comes from in regular methods or "
"where *cls* comes from in class methods, this is it!"
msgstr ""

#: ../../howto/descriptor.rst:862
msgid "Static Methods"
msgstr "静态方法"

#: ../../howto/descriptor.rst:864
msgid ""
"Non-data descriptors provide a simple mechanism for variations on the usual "
"patterns of binding functions into methods."
msgstr "非数据描述器为把函数绑定为方法的通常模式提供了一种简单的机制。"

#: ../../howto/descriptor.rst:867
msgid ""
"To recap, functions have a :meth:`__get__` method so that they can be "
"converted to a method when accessed as attributes.  The non-data descriptor "
"transforms an ``obj.f(*args)`` call into ``f(obj, *args)``.  Calling "
"``cls.f(*args)`` becomes ``f(*args)``."
msgstr ""
"概括地说，函数对象具有 :meth:`__get__` 方法，以便在作为属性访问时可以将其转换为方法。非数据描述符将 ``obj.f(*args)`` "
"的调用会被转换为 ``f(obj, *args)`` 。调用 `klass.f(*args)`` 因而变成 ``f(*args)`` 。"

#: ../../howto/descriptor.rst:872
msgid "This chart summarizes the binding and its two most useful variants:"
msgstr "下表总结了绑定及其两个最有用的变体："

#: ../../howto/descriptor.rst:875
msgid "Transformation"
msgstr "转换形式"

#: ../../howto/descriptor.rst:875
msgid "Called from an object"
msgstr "通过对象调用"

#: ../../howto/descriptor.rst:875
msgid "Called from a class"
msgstr "通过类调用"

#: ../../howto/descriptor.rst:878
msgid "function"
msgstr "函数"

#: ../../howto/descriptor.rst:878
msgid "f(obj, \\*args)"
msgstr "f(obj, \\*args)"

#: ../../howto/descriptor.rst:878 ../../howto/descriptor.rst:880
#: ../../howto/descriptor.rst:880
msgid "f(\\*args)"
msgstr "f(\\*args)"

#: ../../howto/descriptor.rst:880
msgid "staticmethod"
msgstr "静态方法"

#: ../../howto/descriptor.rst:882
msgid "classmethod"
msgstr "类方法"

#: ../../howto/descriptor.rst:882
msgid "f(type(obj), \\*args)"
msgstr "f(type(obj), \\*args)"

#: ../../howto/descriptor.rst:882
msgid "f(cls, \\*args)"
msgstr "f(cls, \\*args)"

#: ../../howto/descriptor.rst:885
msgid ""
"Static methods return the underlying function without changes.  Calling "
"either ``c.f`` or ``C.f`` is the equivalent of a direct lookup into "
"``object.__getattribute__(c, \"f\")`` or ``object.__getattribute__(C, "
"\"f\")``. As a result, the function becomes identically accessible from "
"either an object or a class."
msgstr ""
"静态方法返回底层函数，不做任何更改。调用 ``c.f`` 或 ``C.f`` 等效于通过 ``object.__getattribute__(c, "
"\"f\")`` 或 ``object.__getattribute__(C, \"f\")`` 查找。这样该函数就可以从对象或类中进行相同的访问。"

#: ../../howto/descriptor.rst:891
msgid ""
"Good candidates for static methods are methods that do not reference the "
"``self`` variable."
msgstr "适合作为静态方法的是那些不引用 ``self`` 变量的方法。"

#: ../../howto/descriptor.rst:894
msgid ""
"For instance, a statistics package may include a container class for "
"experimental data.  The class provides normal methods for computing the "
"average, mean, median, and other descriptive statistics that depend on the "
"data. However, there may be useful functions which are conceptually related "
"but do not depend on the data.  For instance, ``erf(x)`` is handy conversion"
" routine that comes up in statistical work but does not directly depend on a"
" particular dataset. It can be called either from an object or the class:  "
"``s.erf(1.5) --> .9332`` or ``Sample.erf(1.5) --> .9332``."
msgstr ""
"例如，一个统计用的包可能包含一个实验数据的容器类。该容器类提供了用于计算数据的平均值，均值，中位数和其他描述性统计信息的常规方法。但是，可能有在概念上相关但不依赖于数据的函数。例如，"
" ``erf(x)`` 是在统计中的便捷转换，但并不直接依赖于特定的数据集。可以从对象或类中调用它： ``s.erf(1.5) --> .9332`` "
"或 ``Sample.erf(1.5) --> .9332``。"

#: ../../howto/descriptor.rst:903
msgid ""
"Since static methods return the underlying function with no changes, the "
"example calls are unexciting::"
msgstr "由于静态方法返回的基础函数没有任何变化，因此示例调用也是平淡无奇的::"

#: ../../howto/descriptor.rst:916
msgid ""
"Using the non-data descriptor protocol, a pure Python version of "
":func:`staticmethod` would look like this::"
msgstr "使用非数据描述器，纯 Python 版本的 :func:`staticmethod` 如下所示::"

#: ../../howto/descriptor.rst:930
msgid "Class Methods"
msgstr "类方法"

#: ../../howto/descriptor.rst:932
msgid ""
"Unlike static methods, class methods prepend the class reference to the "
"argument list before calling the function.  This format is the same for "
"whether the caller is an object or a class::"
msgstr "与静态方法不同，类方法在调用函数之前将类引用放在参数列表的最前。无论调用方是对象还是类，此格式相同::"

#: ../../howto/descriptor.rst:946
msgid ""
"This behavior is useful whenever the method only needs to have a class "
"reference and does rely on data stored in a specific instance.  One use for "
"class methods is to create alternate class constructors.  For example, the "
"classmethod :func:`dict.fromkeys` creates a new dictionary from a list of "
"keys.  The pure Python equivalent is::"
msgstr ""
"当方法仅需要具有类引用并且确实依赖于存储在特定实例中的数据时，此行为就很有用。类方法的一种用途是创建备用类构造函数。例如，类方法  "
":func:`dict.fromkeys` 从键列表创建一个新字典。纯 Python 的等价实现是::"

#: ../../howto/descriptor.rst:963
msgid "Now a new dictionary of unique keys can be constructed like this::"
msgstr "现在可以这样构造一个新的键唯一的字典："

#: ../../howto/descriptor.rst:968
msgid ""
"Using the non-data descriptor protocol, a pure Python version of "
":func:`classmethod` would look like this::"
msgstr "使用非数据描述器协议，纯 Python 版本的 :func:`classmethod` 如下："

#: ../../howto/descriptor.rst:984
msgid ""
"The code path for ``hasattr(obj, '__get__')`` was added in Python 3.9 and "
"makes it possible for :func:`classmethod` to support chained decorators. For"
" example, a classmethod and property could be chained together::"
msgstr ""
" ``hasattr(obj, '__get__')`` 的代码是在 Python 3.9 中加入的，这让 :func:`classmethod` "
"可以支持链式装饰器。例如，一个类方法和属性可以链接在一起::"

#: ../../howto/descriptor.rst:995
msgid "Member Objects"
msgstr "成员对象"

#: ../../howto/descriptor.rst:997
msgid ""
"When a class defines ``__slots__``, it replaces instance dictionaries with a"
" fixed-length array of slot values.  From a user point of view that has "
"several effects:"
msgstr ""

#: ../../howto/descriptor.rst:1001
msgid ""
"1. Provides immediate detection of bugs due to misspelled attribute "
"assignments.  Only attribute names specified in ``__slots__`` are allowed::"
msgstr ""

#: ../../howto/descriptor.rst:1013
msgid ""
"2. Helps create immutable objects where descriptors manage access to private"
" attributes stored in ``__slots__``::"
msgstr ""

#: ../../howto/descriptor.rst:1034
msgid ""
"3. Saves memory.  On a 64-bit Linux build, an instance with two attributes "
"takes 48 bytes with ``__slots__`` and 152 bytes without.  This `flyweight "
"design pattern <https://en.wikipedia.org/wiki/Flyweight_pattern>`_ likely "
"only matters when a large number of instances are going to be created."
msgstr ""

#: ../../howto/descriptor.rst:1039
msgid ""
"4. Blocks tools like :func:`functools.cached_property` which require an "
"instance dictionary to function correctly::"
msgstr ""

#: ../../howto/descriptor.rst:1057
msgid ""
"It's not possible to create an exact drop-in pure Python version of "
"``__slots__`` because it requires direct access to C structures and control "
"over object memory allocation.  However, we can build a mostly faithful "
"simulation where the actual C structure for slots is emulated by a private "
"``_slotvalues`` list.  Reads and writes to that private structure are "
"managed by member descriptors::"
msgstr ""

#: ../../howto/descriptor.rst:1086
msgid ""
"The :meth:`type.__new__` method takes care of adding member objects to class"
" variables.  The :meth:`object.__new__` method takes care of creating "
"instances that have slots instead of a instance dictionary.  Here is a rough"
" equivalent in pure Python::"
msgstr ""

#: ../../howto/descriptor.rst:1112
msgid ""
"To use the simulation in a real class, just inherit from :class:`Object` and"
" set the :term:`metaclass` to :class:`Type`::"
msgstr ""

#: ../../howto/descriptor.rst:1123
msgid ""
"At this point, the metaclass has loaded member objects for *x* and *y*::"
msgstr ""

#: ../../howto/descriptor.rst:1134
msgid ""
"When instances are created, they have a ``slot_values`` list where the "
"attributes are stored::"
msgstr ""

#: ../../howto/descriptor.rst:1144
msgid ""
"Unlike the real ``__slots__``, this simulation does have an instance "
"dictionary just to hold the ``_slotvalues`` array.  So, unlike the real "
"code, this simulation doesn't block assignments to misspelled attributes::"
msgstr ""
